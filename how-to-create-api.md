# Guide Series: How To Create an API? 
Creating an API is not always an easy task. You have to take into account many different parameters and each API is different than the others.

If this is your first time, creating an API then you should work in small tasks: 
1. **Understand the requirements of your task at hand**; what exactly does our API have to do? How should it behave? What code statuses is going to return under which circumstances? If you've been a given a task with requirements then everything is easier. Otherwise, maybe creating a small diagram will help visualise the architecture of the API
2. **Decide which frameworks and libraries to use**; most of the times you don't have to invent the wheel. Look at the other APIs your team has created, if you're using the same DBs or some other resources then you know a great deal of your future tools. Does the other services use Gradle or Maven? It is good to use the same libraries and frameworks the other APIs have in your company. If you don't have anywhere to see for guidance, then search for the best tools for your project. Have in mind though, that your list with the frameworks and libraries will grow also during the implementation of your service.
3. **Create the skeleton of your project**; after you know what you want to implement and decide on the tools, it is time to create your project. Start with the very basics; for example, if you're working with Maven - select the archetype you want to use. Then fill in the pom.xml with the frameworks, libraries and tools you decided upon on task 2. After that you're ready for the implementation!
4. **Start with the model classes**; these classes are the keepers of the business/domain language. A colleague should look at them and understand immediately what these models are about! Every entity should have its model. The step 1 here helps very much.
5. **Work on the repositories**; from where you will get the data that you will populate your models with? Here you should connect with the DBs, other APIs, queues etc. You get the data and then adapt their results to DTOs (Data Transfer Objects), which you will adapt on your model classes later on.
6. **Write unit and integration tests about the repositories**; before continuing with writing the service level classes. You should write the tests for the repositories; unit and integration ones. You should be sure that your code you've written on step 5 is working as expected. If you don't check that, then afterwards you'll have to face it! And believe me if you have to debug and search all of your service to end to the repositories then this is time-consuming! Writing these tests will take you more time in the first tries, but eventually it will take less and less. And also you will have less time for debugging!
7. **Work on the services**; the services are actually the heart of your API. They do all the hard work. They have the logic of your service. They get some inputs from the controllers, communicate with the repositories, combine the data and in the end do whatever our service want to do. Here, the step 1, is valuable because we want efficient services. 
8. **Write unit tests about the services**; yes the same logic here as step 6. Test a lot and early in order to avoid many bugs in the end, which are also time-consuming.
9. **Work on the controllers**; the controllers are the interface of our service with the outside world. You should create them with care. They should be understandable by all our colleagues and do exactly the job that we want. They provide the service layer with the data to start their own work. Do not return the domain class even if it seems the obvious. Create DTOs for each case e.g. GetUserResponseDto, CreateUserRequestDto. DTOs are part of your API so semantically they should be different even if they seem to be similar.
10. **Write unit tests about the controllers**; tests again and again! For the same reason! 
11. **Write component tests**; test your api e2e. Send a request to your api and receive the response. Test if everything works as expected. Ideally, you should work with a different DB. The best way is to use docker containers here - have all the repos up in containers, populate them with the correct data and do your testing!
12. Finally, add swagger, code linting, jacoco etc

